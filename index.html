<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>神思 Sansi</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        @font-face {
            font-family: 'MyCustomFont';
            font-weight: normal;
            font-style: normal;
            src: url('./custom.ttf') format('truetype');
            font-display: swap; 
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #E8E6E1; 
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: pointer;
            font-family: 'MyCustomFont', 'Noto Serif TC', serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body::before {
            content: "";
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            opacity: 0.6; pointer-events: none; z-index: 0;
        }

        canvas { 
            display: block; 
            position: absolute; top: 0; left: 0; z-index: 1;
            /* --- GPU 強制加速關鍵 CSS --- */
            transform: translate3d(0, 0, 0); /* 強制開啟硬體加速層 */
            backface-visibility: hidden;     /* 避免閃爍 */
            perspective: 1000px;
            will-change: transform;          /* 提示瀏覽器此元素會頻繁變動 */
        }

        .seal {
            position: absolute; bottom: 18%; left: 50%; transform: translateX(-50%);
            width: 40px; height: 40px;
            border: 2px solid #A84646; color: #A84646;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px;
            font-family: "Noto Serif TC", serif !important; 
            opacity: 0; animation: fadeIn 2s ease-in forwards 0.5s; 
            z-index: 2; letter-spacing: 2px; writing-mode: vertical-rl;
            pointer-events: none;
        }

        .cta-text {
            position: absolute;
            top: 58%; left: 50%; transform: translateX(-50%);
            font-size: 13px; color: #555;
            font-family: "Noto Serif TC", serif;
            letter-spacing: 4px;
            opacity: 0; animation: fadeInText 1.5s ease-in forwards 1s; 
            z-index: 2; pointer-events: none; text-align: center;
        }
        
        .cta-text::after {
            content: "↓"; display: block; margin-top: 5px; font-size: 12px; opacity: 0.6;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #E8E6E1; opacity: 0; pointer-events: none;
            transition: opacity 0.8s ease-in-out; 
            z-index: 10;
        }

        @keyframes fadeIn { to { opacity: 0.7; } }
        @keyframes fadeInText { to { opacity: 0.6; } }

    </style>
</head>
<body>
    <div id="overlay"></div>
    <div class="cta-text">點擊前往</div>
    <div class="seal" id="seal">神思</div>
    <canvas id="canvas1"></canvas>

    <script>
        const canvas = document.getElementById('canvas1');
        
        // --- GPU 加速核心設定 ---
        const ctx = canvas.getContext('2d', { 
            willReadFrequently: true, // 優化 getImageData 讀取速度
            alpha: true,              // 允許透明背景合成
            desynchronized: true      // 關鍵：解除渲染同步鎖，允許 GPU 直接繪製 (降低延遲)
        });
        
        const overlay = document.getElementById('overlay');
        const seal = document.getElementById('seal');
        const ctaText = document.querySelector('.cta-text');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particleArray = [];
        let isExploding = false;
        
        const fontName = 'MyCustomFont';
        const mouse = { x: undefined, y: undefined, radius: 100 }

        window.addEventListener('mousemove', (e) => { mouse.x = e.x; mouse.y = e.y; });
        window.addEventListener('mouseout', () => { mouse.x = undefined; mouse.y = undefined; });
        const handleTouch = (e) => {
            e.preventDefault();
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        };
        window.addEventListener('touchmove', handleTouch, { passive: false });
        window.addEventListener('touchstart', handleTouch, { passive: false });
        window.addEventListener('touchend', () => { mouse.x = undefined; mouse.y = undefined; });

        function handleClick() {
            if(!isExploding) {
                isExploding = true;
                if (mouse.x === undefined) {
                    mouse.x = canvas.width / 2;
                    mouse.y = canvas.height / 2;
                }
                mouse.radius = 5000; 

                seal.style.transition = "opacity 0.3s";
                seal.style.opacity = 0;
                ctaText.style.transition = "opacity 0.3s";
                ctaText.style.opacity = 0;

                setTimeout(() => {
                    overlay.style.opacity = 1; 
                    setTimeout(() => {
                        window.location.href = "https://kenchan20141.github.io/AIChinese/"; 
                    }, 400); 
                }, 300); 
            }
        }

        window.addEventListener('click', handleClick);
        let isDragging = false;
        window.addEventListener('touchmove', () => isDragging = true);
        window.addEventListener('touchend', () => {
            if (!isDragging) handleClick();
            isDragging = false;
        });

        class Particle {
            constructor(x, y){
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.baseX = x;
                this.baseY = y;
                this.density = (Math.random() * 30) + 1;
                
                this.r = 62 + Math.random() * 20;
                this.g = 78 + Math.random() * 20;
                this.b = 80 + Math.random() * 20;
                this.a = 0.3 + Math.random() * 0.5; 
                
                // 維持您要求的細膩度
                this.size = 1.2; 
            }
            
            draw(){
                // 這裡保留 arc (圓形)，確保墨水邊緣的圓潤感完全不變
                ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill(); // 移除了 closePath，對於填滿的圓形來說是不必要的，能省一點點計算
            }

            update(){
                if (isExploding) {
                    this.x += (Math.random() - 0.5) * 30;
                    this.y += (Math.random() - 0.5) * 30;
                    this.a -= 0.02; 
                    if (this.a < 0) this.a = 0;
                    return;
                }

                if (mouse.x !== undefined && mouse.y !== undefined) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distSq = dx*dx + dy*dy; // 優化：使用距離平方比較，減少 Math.sqrt 開根號運算
                    let radSq = mouse.radius * mouse.radius;
                    
                    if (distSq < radSq){
                        let distance = Math.sqrt(distSq);
                        let forceDirectionX = dx / distance;
                        let forceDirectionY = dy / distance;
                        let force = (mouse.radius - distance) / mouse.radius;
                        let directionX = forceDirectionX * force * this.density;
                        let directionY = forceDirectionY * force * this.density;

                        this.x -= directionX;
                        this.y -= directionY;
                        return; 
                    }
                }

                if (this.x !== this.baseX){
                    let dx = this.x - this.baseX;
                    this.x -= dx/15; 
                }
                if (this.y !== this.baseY){
                    let dy = this.y - this.baseY;
                    this.y -= dy/15;
                }
            }
        }

        function init(){
            particleArray = [];
            
            // 維持修正後的字體與位置
            let fontSize = window.innerWidth < 600 ? 
                           window.innerWidth * 0.3 : 
                           Math.min(window.innerWidth, window.innerHeight) * 0.22;
            
            ctx.font =  `700 ${fontSize}px "${fontName}", "Noto Serif TC", serif`; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white'; 
            
            let yOffset = window.innerHeight * 0.40;
            ctx.fillText('神思', canvas.width/2, yOffset); 
            
            const textCoordinates = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 維持高密度 (像素級)
            const gap = 1; 

            for (let y = 0, y2 = textCoordinates.height; y < y2; y += gap){
                for (let x = 0, x2 = textCoordinates.width; x < x2; x += gap){
                    // 閾值維持 128，確保字體邊緣銳利
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128){
                        particleArray.push(new Particle(x, y));
                    }
                }
            }
        }

        function animate(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < particleArray.length; i++){
                particleArray[i].draw();
                particleArray[i].update();
            }
            requestAnimationFrame(animate);
        }

        document.fonts.ready.then(function() {
            setTimeout(() => {
                init();
                animate();
            }, 100); 
        });

        let resizeTimeout;
        window.addEventListener('resize', function(){
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                init();
            }, 200);
        });
    </script>
</body>
</html>
